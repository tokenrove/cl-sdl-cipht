(in-package :net.cipht/sdl2)

;; Keyboard key definitions: 8-bit ISO-8859-1 (Latin 1) encoding is used
;; for printable keys (such as A-Z, 0-9 etc), and values above 256
;; represent special (non-printable) keys (e.g. F1, Page Up etc).

(eval-when (:compile-toplevel :load-toplevel :execute)
  (define-foreign-type key-code-type ()
    ()
    (:actual-type :int)
    (:simple-parser key-code))

  (let ((symbol-table '((:unknown -1)
                        (:up 273)
                        (:down 274)
                        (:right 275)
                        (:left 276)
                        (:insert 277)
                        (:home 278)
                        (:end 279)
                        (:pageup 280)
                        (:pagedown 281)
                        (:f1 282)
                        (:f2 283)
                        (:f3 284)
                        (:f4 285)
                        (:f5 286)
                        (:f6 287)
                        (:f7 288)
                        (:f8 289)
                        (:f9 290)
                        (:f10 291)
                        (:f11 292)
                        (:f12 293)
                        (:f13 294)
                        (:f14 295)
                        (:f15 296)
                        (:numlock 300)
                        (:capslock 301)
                        (:scrollock 302)
                        (:rshift 303)
                        (:lshift 304)
                        (:rctrl 305)
                        (:lctrl 306)
                        (:ralt 307)
                        (:lalt 308)
                        (:rmeta 309)
                        (:lmeta 310)
                        (:lsuper 311)
                        (:rsuper 312)
                        (:mode 313)
                        (:compose 314)
                        (:help 315)
                        (:print 316)
                        (:sysreq 317)
                        (:break 318)
                        (:menu 319))))
    (defmethod expand-to-foreign (value (type key-code-type))
      `(cl:cond ((characterp ,value) (char-code ,value))
                ((symbolp ,value) (ecase ,value
                                    ,@symbol-table))
                (t ,value)))
    (defmethod translate-to-foreign (value (type key-code-type))
      (cl:cond ((characterp value) (char-code value))
                ((symbolp value) (second (find value symbol-table :key #'car)))
                (t value)))
    (defmethod translate-from-foreign (value (type key-code-type))
      (if-let (it (find value symbol-table :key #'second)) ;; XXX probably doesn't work where fixnums aren't EQL
        (first it)
        (code-char value)))
    (defmethod expand-from-foreign (value (type key-code-type))
      `(case ,value
         ,@(mapcar #'reverse symbol-table) ;; XXX probably doesn't work where fixnums aren't EQL
         (t (code-char ,value))))))

(defcenum mod
  (:none #x0000)
  (:lshift #x0001)
  (:rshift #x0002)
  (:lctrl #x0040)
  (:rctrl #x0080)
  (:lalt #x0100)
  (:ralt #x0200)
  (:lmeta #x0400)
  (:rmeta #x0800)
  (:num #x1000)
  (:caps #x2000)
  (:mode #x4000)
  (:reserved #x800)
  (:ctrl #.(logior #x40 #x80))
  (:shift #.(logior #x1 #x2))
  (:alt #.(logior #x100 #x200))
  (:meta #.(logior #x400 #x800)))
